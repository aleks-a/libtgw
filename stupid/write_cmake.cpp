#include "write_cmake.h"


static std::string make_up_src(const std::string &base);

void write_cmake(const std::string &dir, const gen_config &cfg, token_table_t &tokens)
{
	(void)cfg;
	std::string path = dir + FSS + "stupid_autobuild.cmake";
	std::ofstream ofs(path.c_str(), std::ios_base::out | std::ios_base::trunc);
	if(ofs.fail())
	{
		throw stupid_exception("Failed to open file %s", path.c_str());
	}
	
	ofs << "# Automatically generated by Stupid" << std::endl << std::endl;
	
	token_table_t::iterator it;
	for(it = tokens.begin(); it != tokens.end(); ++it)
	{
		if( ! (*it).autobuild) { continue; }
		
		if((*it).autobuild_srcs.empty())
		{
			const std::string ext = make_up_src(dir + (*it).name);
			(*it).autobuild_srcs = (*it).name + "." + ext;
		}
		
		ofs << "add_executable(" << (*it).name << " " << (*it).autobuild_srcs << ")" << std::endl;
		ofs << "target_link_libraries(" << (*it).name << " ${STUPID_AUTOBUILD_LIBS})" << std::endl << std::endl;
		if( ! ofs.good() )
		{
			throw stupid_exception("Error while writing file \"%s\"", path.c_str());
		}
	}
}


#define TEST_EXT(EXT) \
	tmp = base + "." + EXT; if(file_exists(tmp.c_str())) { return EXT; }

static std::string make_up_src(const std::string &base)
{
	std::string tmp;
	TEST_EXT("c")
	TEST_EXT("cc")
	TEST_EXT("cpp")
	TEST_EXT("cxx")
	
	throw stupid_exception("Can't find source for %s", base.c_str()); 
}
